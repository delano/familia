# Real-world validation scenarios testing complex application workflows

require_relative '../helpers/test_helpers'
require_relative '../../lib/familia/validation'

# Real-world test models that demonstrate complex validation scenarios
class User < Familia::Horreum
  identifier_field :user_id
  field :user_id
  field :username
  field :email
  field :created_at
  field :last_login
  field :status

  list :activity_log
  set :permissions
  zset :scores
  hashkey :preferences
end

class BlogPost < Familia::Horreum
  identifier_field :post_id
  field :post_id
  field :title
  field :content
  field :author_id
  field :published_at
  field :status

  list :comments
  set :tags
  zset :ratings
end

class Session < Familia::Horreum
  identifier_field :session_id
  field :session_id
  field :user_id
  field :created_at
  field :expires_at
  field :ip_address
end

# Service classes that perform complex operations
class UserService
  def self.create_user_with_profile(user_data)
    # Should be atomic - user creation + initial setup
    user = User.new(user_data)

    Familia.transaction do |conn|
      # Save user data
      user_data.each do |field, value|
        conn.hset(user.dbkey, field.to_s, value.to_s)
      end

      # UnsortedSet default permissions
      conn.sadd("#{user.dbkey.sub(':object', ':permissions')}", "read")

      # Initialize empty activity log
      conn.lpush("#{user.dbkey.sub(':object', ':activity_log')}", "account_created")

      # UnsortedSet default score
      conn.zadd("#{user.dbkey.sub(':object', ':scores')}", 0, "reputation")
    end

    user
  end

  def self.login_user(user_id, session_data)
    user = User.new(user_id: user_id)
    session = Session.new(session_data)

    # Should be atomic - update last login + create session
    Familia.transaction do |conn|
      # Update user last login
      conn.hset(user.dbkey, "last_login", Time.now.to_i.to_s)

      # Create session
      session_data.each do |field, value|
        conn.hset(session.dbkey, field.to_s, value.to_s)
      end

      # Log activity
      conn.lpush("#{user.dbkey.sub(':object', ':activity_log')}", "logged_in:#{Time.now.to_i}")
    end

    { user: user, session: session }
  end
end

class BlogService
  def self.publish_post(post_data, author_id)
    post = BlogPost.new(post_data.merge(author_id: author_id))

    # Should be atomic - create post + update author stats
    user = User.new(user_id: author_id)

    Familia.transaction do |conn|
      # Save post
      post_data.each do |field, value|
        conn.hset(post.dbkey, field.to_s, value.to_s)
      end
      conn.hset(post.dbkey, "author_id", author_id)
      conn.hset(post.dbkey, "published_at", Time.now.to_i.to_s)
      conn.hset(post.dbkey, "status", "published")

      # Update author score
      conn.zincrby("#{user.dbkey.sub(':object', ':scores')}", 10, "posts_published")

      # Log activity
      conn.lpush("#{user.dbkey.sub(':object', ':activity_log')}", "published_post:#{post.post_id}")
    end

    post
  end
end

extend Familia::Validation::TestHelpers
setup_validation_test

## Clean up existing test data
cleanup_keys = Familia.dbclient.keys("user:*")
cleanup_keys.concat(Familia.dbclient.keys("blogpost:*"))
cleanup_keys.concat(Familia.dbclient.keys("session:*"))
Familia.dbclient.del(*cleanup_keys) if cleanup_keys.any?
true
#=> true

## Real-world user creation scenario validates correctly
assert_atomic_operation do |expect|
  expect.transaction do |tx|
    tx.hset("user:john123:object", "user_id", "john123")
      .hset("user:john123:object", "username", "john_doe")
      .hset("user:john123:object", "email", "john@example.com")
      .sadd("user:john123:permissions", "read")
      .lpush("user:john123:activity_log", "account_created")
      .zadd("user:john123:scores", "0", "reputation")
  end

  UserService.create_user_with_profile({
    user_id: "john123",
    username: "john_doe",
    email: "john@example.com"
  })
end
#=> true

## User login scenario with session creation validates atomically
user_data = { user_id: "alice456", username: "alice", email: "alice@example.com" }
existing_user = UserService.create_user_with_profile(user_data)

assert_atomic_operation do |expect|
  expect.transaction do |tx|
    tx.hset("user:alice456:object", "last_login", any_string)
      .hset("session:sess789:object", "session_id", "sess789")
      .hset("session:sess789:object", "user_id", "alice456")
      .hset("session:sess789:object", "ip_address", "192.168.1.1")
      .lpush("user:alice456:activity_log", match_regex(/logged_in:/))
  end

  UserService.login_user("alice456", {
    session_id: "sess789",
    user_id: "alice456",
    ip_address: "192.168.1.1"
  })
end
#=> true

## Blog post publishing with author score update validates correctly
# Create author first
author = UserService.create_user_with_profile({
  user_id: "writer1",
  username: "writer",
  email: "writer@blog.com"
})

assert_atomic_operation do |expect|
  expect.transaction do |tx|
    tx.hset("blogpost:post001:object", "post_id", "post001")
      .hset("blogpost:post001:object", "title", "My First Post")
      .hset("blogpost:post001:object", "content", "Hello world!")
      .hset("blogpost:post001:object", "author_id", "writer1")
      .hset("blogpost:post001:object", "published_at", any_string)
      .hset("blogpost:post001:object", "status", "published")
      .zincrby("user:writer1:scores", "10", "posts_published")
      .lpush("user:writer1:activity_log", "published_post:post001")
  end

  BlogService.publish_post({
    post_id: "post001",
    title: "My First Post",
    content: "Hello world!"
  }, "writer1")
end
#=> true

## Complex multi-object operation validates with proper expectations
assert_redis_commands do |expect|
  expect.strict_order(false)  # Allow flexible order for complex operations
        .transaction do |tx|
          tx.hset("user:batch1:object", "user_id", "batch1")
            .hset("user:batch1:object", "username", "batcher")
            .sadd("user:batch1:permissions", "read")
            .lpush("user:batch1:activity_log", "account_created")
            .zadd("user:batch1:scores", "0", "reputation")
        end
        .transaction do |tx|
          tx.hset("blogpost:batch_post:object", "post_id", "batch_post")
            .hset("blogpost:batch_post:object", "title", "Batch Post")
            .hset("blogpost:batch_post:object", "author_id", "batch1")
            .hset("blogpost:batch_post:object", "published_at", any_string)
            .hset("blogpost:batch_post:object", "status", "published")
            .zincrby("user:batch1:scores", "10", "posts_published")
            .lpush("user:batch1:activity_log", "published_post:batch_post")
        end

  # Execute complex workflow
  user = UserService.create_user_with_profile({
    user_id: "batch1",
    username: "batcher"
  })

  BlogService.publish_post({
    post_id: "batch_post",
    title: "Batch Post"
  }, "batch1")
end
#=> true

## Performance analysis on real-world operations shows efficiency
validator = Familia::Validation::Validator.new(performance_tracking: true)
commands = validator.capture_redis_commands do
  # Simulate real application load
  users = []
  posts = []

  # Create multiple users efficiently
  (1..3).each do |i|
    users << UserService.create_user_with_profile({
      user_id: "perf_user#{i}",
      username: "perfuser#{i}",
      email: "perf#{i}@example.com"
    })
  end

  # Each user publishes a post
  users.each_with_index do |user, i|
    posts << BlogService.publish_post({
      post_id: "perf_post#{i + 1}",
      title: "Performance Post #{i + 1}",
      content: "Content for performance testing"
    }, user.user_id)
  end
end

analysis = validator.analyze_performance(commands)
[
  analysis[:total_commands] > 10,  # Should have many commands
  analysis[:transaction_efficiency][:score] > 0.5,  # Good transaction usage
  analysis[:efficiency_score] > 60  # Reasonable efficiency
]
#=> [true, true, true]

## Familia test helpers work with real-world objects
user = User.new(user_id: "helper_test", username: "helper", email: "helper@test.com")

assert_familia_save(user, {
  user_id: "helper_test",
  username: "helper",
  email: "helper@test.com"
})
#=> true

## Data type operations validate correctly with helpers
user = User.new(user_id: "data_test", username: "datatester")
user.save

assert_list_operation(user, :activity_log, :lpush, "test_activity") do
  # This should execute: LPUSH user:data_test:activity_log test_activity
end
#=> true

## Test set operation validation
assert_set_operation(user, :permissions, :sadd, "admin") do
  # This should execute: SADD user:data_test:permissions admin
end
#=> true

## Test sorted set operation validation
assert_sorted_set_operation(user, :scores, :zadd, 100, "test_score") do
  # This should execute: ZADD user:data_test:scores 100 test_score
end
#=> true

## Mixed atomic and non-atomic operations are properly categorized
validator = Familia::Validation::Validator.new(strict_atomicity: true)
commands = validator.capture_redis_commands do
  user = User.new(user_id: "mixed_test", username: "mixed")

  # Non-atomic operation
  user.save

  # Atomic operation
  user.batch_update(status: "active", last_login: Time.now.to_i.to_s)

  # Non-atomic operation
  user.activity_log.unshift("status_updated")
end

atomic_count = commands.commands.count(&:atomic_command?)
non_atomic_count = commands.commands.count { |cmd| !cmd.atomic_command? }

[atomic_count > 0, non_atomic_count > 0]
#=> [true, true]

## Edge case: Empty transaction is detected but doesn't fail validation
validator = Familia::Validation::Validator.new
result = validator.validate do |expect|
  expect.transaction do |tx|
    # Empty transaction expectation
  end

  # Execute empty transaction
  Familia.transaction do |conn|
    # No operations inside transaction
  end
end

result.valid? && result.warning_messages.any?
#=> true

## Error scenarios are properly handled and reported
validator = Familia::Validation::Validator.new
result = validator.validate do |expect|
  expect.hset("wrong:key", "field", "value")  # Wrong expectation

  # Execute different operation
  user = User.new(user_id: "error_test", username: "error")
  user.save
end

[
  !result.valid?,
  result.error_messages.any?,
  result.detailed_report.include?("FAIL")
]
#=> [true, true, true]

## Flexible matching works for dynamic scenarios
validator = Familia::Validation::Validator.new
result = validator.validate do |expect|
  expect.strict_order(false)
        .allow_extra_commands(true)
        .match_pattern(/HSET user:dynamic\d+:object/)
        .match_pattern(/SADD user:dynamic\d+:permissions/)

  # Execute with dynamic ID
  dynamic_id = "dynamic#{Time.now.to_i}"
  user = UserService.create_user_with_profile({
    user_id: dynamic_id,
    username: "dynamic_user"
  })
end

result.valid?
#=> true

## Debug helpers provide useful output for troubleshooting
commands = capture_redis_commands do
  user = User.new(user_id: "debug_test", username: "debugger")
  user.save
  user.permissions.add("debug")
end

# These should not raise errors and should provide useful output
debug_commands = commands.commands.map(&:to_s)
debug_commands.length > 0 && debug_commands.all? { |cmd| cmd.is_a?(String) }
#=> true

## Cleanup test environment
teardown_validation_test

## Clean up test data
cleanup_keys = Familia.dbclient.keys("user:*")
cleanup_keys.concat(Familia.dbclient.keys("blogpost:*"))
cleanup_keys.concat(Familia.dbclient.keys("session:*"))
Familia.dbclient.del(*cleanup_keys) if cleanup_keys.any?
true
#=> true
