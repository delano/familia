# Validation testing for performance analysis and optimization detection

require_relative '../helpers/test_helpers'
require_relative '../../lib/familia/validation'

extend Familia::Validation::TestHelpers

# Initialize validation framework
setup_validation_test

# Test models for performance validation
class PerformanceTestUser < Familia::Horreum
  identifier_field :user_id
  field :user_id
  field :name
  field :email
  field :status
  list :activities
  set :tags
  zset :scores
end

class PerformanceTestPost < Familia::Horreum
  identifier_field :post_id
  field :post_id
  field :title
  field :content
  field :author_id

  def load_with_author
    # Inefficient - loads author separately (N+1 pattern)
    author = PerformanceTestUser.new(user_id: author_id)
    author.refresh!
    { post: self, author: author }
  end

  def efficient_load_with_author
    # More efficient - could batch this operation
    author_data = Familia.dbclient.hgetall("performancetestuser:#{author_id}:object")
    author = PerformanceTestUser.new(user_id: author_id)
    author_data.each { |k, v| author.send("#{k}=", v) if author.respond_to?("#{k}=") }
    { post: self, author: author }
  end
end

extend Familia::Validation::TestHelpers
setup_validation_test

## Clean up existing test data
cleanup_keys = Familia.dbclient.keys("performancetest*")
Familia.dbclient.del(*cleanup_keys) if cleanup_keys.any?
true
#=> true

## Performance analysis captures timing information
validator = Familia::Validation::Validator.new(performance_tracking: true)
commands = validator.capture_redis_commands do
  user = PerformanceTestUser.new(user_id: "perf1", name: "Performance Test", email: "perf@test.com")
  user.save
  user.activities.unshift("activity1", "activity2", "activity3")
  user.tags.add("tag1", "tag2")
  user.scores.add(100, "score1")
end

analysis = validator.analyze_performance(commands)
analysis[:total_commands] > 0 && analysis[:total_duration_ms] >= 0
#=> true

## Performance analysis detects command type breakdown
validator = Familia::Validation::Validator.new(performance_tracking: true)
commands = validator.capture_redis_commands do
  user = PerformanceTestUser.new(user_id: "perf2", name: "Test User")
  user.save  # Hash operations
  user.activities.unshift("item")  # List operation
  user.tags.add("tag")  # Set operation
  user.scores.add(50, "score")  # Sorted set operation
end

analysis = validator.analyze_performance(commands)
breakdown = analysis[:command_type_breakdown]
breakdown.keys.length > 1  # Should have multiple command types
#=> true

## assert_performance_within helper works
result = assert_performance_within(1000) do  # 1 second limit
  user = PerformanceTestUser.new(user_id: "perf3", name: "Speed Test")
  user.save
end
result
#=> true

## assert_efficient_commands detects N+1 patterns
posts_data = (1..5).map do |i|
  PerformanceTestPost.new(post_id: "post#{i}", title: "Post #{i}",
                         content: "Content #{i}", author_id: "user#{i}")
end

# Create users first
(1..5).each do |i|
  user = PerformanceTestUser.new(user_id: "user#{i}", name: "User #{i}")
  user.save
end

# Save posts
posts_data.each(&:save)

# This should trigger N+1 detection (multiple separate HGETALL calls)
begin
  assert_efficient_commands do
    posts_data.each do |post|
      post.load_with_author  # Separate query for each author
    end
  end
  false  # Should not reach here
rescue Familia::Validation::ValidationError
  true   # Expected - N+1 pattern detected
end
#=> true

## Efficient commands pass validation
assert_efficient_commands do
  # Single user operation - no N+1 pattern
  user = PerformanceTestUser.new(user_id: "efficient1", name: "Efficient User")
  user.save
  user.activities.unshift("single_activity")
end
#=> true

## Performance metrics include slowest commands
validator = Familia::Validation::Validator.new(performance_tracking: true)
commands = validator.capture_redis_commands do
  # Create operations of varying complexity
  user = PerformanceTestUser.new(user_id: "slow_test", name: "Slow Test")
  user.save

  # Multiple list operations (potentially slower)
  (1..10).each { |i| user.activities.unshift("item#{i}") }
end

analysis = validator.analyze_performance(commands)
analysis[:slowest_commands].length > 0
#=> true

## Transaction efficiency is calculated correctly
validator = Familia::Validation::Validator.new(performance_tracking: true)
commands = validator.capture_redis_commands do
  user = PerformanceTestUser.new(user_id: "tx_test", name: "Transaction Test")
  user.save

  # Use transaction for batch operations
  Familia.transaction do |conn|
    conn.hset(user.dbkey, "status", "active")
    conn.hset(user.dbkey, "email", "tx@test.com")
    conn.lpush("#{user.dbkey.sub(':object', ':activities')}", "tx_activity")
  end
end

analysis = validator.analyze_performance(commands)
efficiency = analysis[:transaction_efficiency]
efficiency[:score] > 0 && efficiency[:details].include?("transaction")
#=> true

## Empty command sequence analysis handles gracefully
empty_commands = Familia::Validation::CommandRecorder::CommandSequence.new
analysis = Familia::Validation::PerformanceAnalyzer.new(empty_commands).analyze
analysis[:total_commands] == 0 && analysis[:efficiency_score] >= 0
#=> true

## Performance analysis identifies potential batching opportunities
validator = Familia::Validation::Validator.new(performance_tracking: true)
commands = validator.capture_redis_commands do
  # Multiple similar operations that could be batched
  user = PerformanceTestUser.new(user_id: "batch_test")
  user.save

  # Multiple separate HSET operations - could be HMSET
  (1..5).each do |i|
    Familia.dbclient.hset(user.dbkey, "field#{i}", "value#{i}")
  end
end

analysis = validator.analyze_performance(commands)
n_plus_one_patterns = analysis[:potential_n_plus_one]
n_plus_one_patterns.any? { |pattern| pattern[:command] == "HSET" }
#=> true

## Command sequence metadata is accurate
validator = Familia::Validation::Validator.new
commands = validator.capture_redis_commands do
  user = PerformanceTestUser.new(user_id: "meta_test", name: "Metadata Test")
  user.save
  user.activities.unshift("test_activity")

  Familia.transaction do |conn|
    conn.hset(user.dbkey, "status", "verified")
    conn.incr("meta_counter")
  end
end

[
  commands&.command_count.to_i > 0,
  commands&.transaction_count.to_i == 1,
  commands&.transaction_blocks&.first&.command_count.to_i == 2
]
#=> [true, true, true]

## Recorded commands contain proper context information
validator = Familia::Validation::Validator.new
commands = validator.capture_redis_commands do
  user = PerformanceTestUser.new(user_id: "context_test")
  user.save

  Familia.transaction do |conn|
    conn.hset(user.dbkey, "test_field", "test_value")
  end
end

transaction_commands = commands.commands.select(&:atomic_command?)
non_transaction_commands = commands.commands.reject(&:atomic_command?)

transaction_commands.any? && non_transaction_commands.any?
#=> true

## Performance thresholds can be customized
begin
  assert_performance_within(1) do  # Very tight 1ms limit
    # This will likely exceed 1ms
    user = PerformanceTestUser.new(user_id: "timeout_test", name: "Timeout Test")
    user.save
    (1..10).each { |i| user.activities.unshift("item#{i}") }
  end
  false  # Should not reach here
rescue Familia::Validation::ValidationError => e
  e.message.include?("took") && e.message.include?("expected less than")
end
#=> true

## Efficiency score calculation includes multiple factors
validator = Familia::Validation::Validator.new(performance_tracking: true)

# Inefficient pattern - lots of individual operations
commands_inefficient = validator.capture_redis_commands do
  user = PerformanceTestUser.new(user_id: "inefficient", name: "Inefficient")
  user.save

  # Many individual operations instead of batching
  (1..20).each do |i|
    Familia.dbclient.hset("test:key#{i}", "field", "value#{i}")
  end
end

# Efficient pattern - using transactions
commands_efficient = validator.capture_redis_commands do
  user = PerformanceTestUser.new(user_id: "efficient", name: "Efficient")
  user.save

  Familia.transaction do |conn|
    (1..5).each do |i|
      conn.hset(user.dbkey, "field#{i}", "value#{i}")
    end
  end
end

analysis_inefficient = validator.analyze_performance(commands_inefficient)
analysis_efficient = validator.analyze_performance(commands_efficient)

analysis_efficient[:efficiency_score] > analysis_inefficient[:efficiency_score]
#=> true

## Command duration tracking works
validator = Familia::Validation::Validator.new
commands = validator.capture_redis_commands do
  user = PerformanceTestUser.new(user_id: "duration_test", name: "Duration Test")
  user.save
end

first_command = commands&.commands&.first
first_command&.duration_us.to_i >= 0 && first_command&.timestamp.is_a?(Time)
#=> true

## Transaction boundaries are properly detected in complex scenarios
validator = Familia::Validation::Validator.new
commands = validator.capture_redis_commands do
  user1 = PerformanceTestUser.new(user_id: "complex1", name: "Complex 1")
  user2 = PerformanceTestUser.new(user_id: "complex2", name: "Complex 2")

  # Mixed atomic and non-atomic operations
  user1.save  # Non-atomic
  user2.save  # Non-atomic

  # Atomic batch update
  Familia.transaction do |conn|
    conn.hset(user1.dbkey, "status", "active")
    conn.hset(user2.dbkey, "status", "active")
    conn.incr("active_user_count")
  end

  # More non-atomic operations
  user1.activities.unshift("logged_in")
  user2.activities.unshift("logged_in")
end

atomic_commands = commands.commands.select(&:atomic_command?)
non_atomic_commands = commands.commands.reject(&:atomic_command?)

[
  commands&.transaction_count.to_i == 1,
  commands&.transaction_blocks&.first&.command_count.to_i == 3,
  atomic_commands&.length.to_i == 3,
  non_atomic_commands&.length.to_i > 3
]
#=> [true, true, true, true]

## Cleanup test environment
teardown_validation_test

## Clean up test data
cleanup_keys = Familia.dbclient.keys("performancetest*")
cleanup_keys.concat(Familia.dbclient.keys("test:key*"))
cleanup_keys.concat(Familia.dbclient.keys("meta_counter"))
cleanup_keys.concat(Familia.dbclient.keys("active_user_count"))
Familia.dbclient.del(*cleanup_keys) if cleanup_keys.any?
true
#=> true
